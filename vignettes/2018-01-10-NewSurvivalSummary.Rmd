---
title: "Updated Method for Analyzing Survival in Entangled Right Whales"
author: "Rob Schick"
date: "February 11, 2018"
output: word_document
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(lubridate)
library(dplyr)
library(tangled)
library(tidyr)
library(purrr)
```

The purpose of this document is to provide an initial overview of the suggested changes for analyzing the survival output from the right whale model. Our goal is to summarize survival by injury -- in order of increasing severity:

1. Severe with gear
2. Moderate with gear
3. Severe without gear
4. Minor with gear
5. Moderate without gear
6. Minor without gear

...and ideally to do this for both males and females. For now, we won't investigate the effects of age..

Though we had previously done this using the the Kaplan-Meier apprach, Jim now feels that is the incorrect metric because you have to know who survived. I had previously implemented this using the right censoring approach, but he doesn't want to go that route. Instead, what he proposes is to build up comparisons between the posterior estimate of survival probability for survival of the entangled animal - following the end of the last event, and compare it to the mean survival probability of reference animals during the period from the end of the entanglement until the survival probability goes to 0.

The algorithm would look something like this.

1. We start by extracting the last entanglement event from this animal
2. From that we gather the time information corresponding to the end of the window
3. Calculate the survival probability from the end of entanglement window until presumed death

We start by assembling and viewing a data frame of all of the last entanglement event for each animal:

```{r lastEvents}
tangEvents <- tangleOut %>% 
  group_by(EGNo) %>% 
  filter(EventNo == max(EventNo)) %>% 
  arrange(EGNo)
```

For the paper, we also excluded animals that were ship struck, or had severe prop scars. This list is below:

```{r}
exclude <- c(1004, 1006, 1014, 1045, 1128, 1223, 1267, 1308, 1504, 1623, 1907, 1909, 2143, 2150, 2220, 2250, 2404, 2425, 2450, 2617, 2820, 3508, 3522, 3853)
tangSub <- tangEvents %>% 
  filter(!(EGNo %in% exclude))
```


## Entangled Animal
We'll start with the first animal to illustrate the algorithm; once complete we'll run it for all animals. 

```{r}
event1 <- tangSub[1, ]
event1
```

This particular animal had one event with a very long possible window. We shortened that to be approximately 4 months: 

* Start of window: ```r event1$StartDateWindow```
* End of window: ```r event1$EndDateWindow```

We need to find its survival probability over that window:

```{r}
idx <- which(ID == event1$EGNo)
svec <- 1 - cumsum(deathyr[idx, ] / ng) 
svec[1:firstSight[idx]] <- NA
```

Now we want to define the window and view the survival probability over that window.

```{r}
w <- which(deathyr[idx, ] > 0)
w1 <- min(w)
w2 <- max(w)
theta <- svec[(w1 - 1):w2]
testVar <- theta * (1 - theta)
plot(theta, type = 'l', ylab = 'Survival Probability', 
     xlab = 'Months Following End of Entanglement',
     main = paste0("Sighting EGNo: ", event1$EGNo))
lines(theta + testVar, lty = 2)
lines(theta - testVar, lty = 2)
```

## Survival Dataframe
Let's iterate over animal-specific events and compile a data frame with rows for each entangled individual. Since the time windows will change for each event, I'll keep the survival probabilities in a list column.

```{r}
getSurv <- function(EGNo, tangSub){
  idx <- which(ID == EGNo)
  svec <- 1 - cumsum(deathyr[idx, ] / ng) 
  svec[1:firstSight[idx]] <- NA
  w1 <- which(myName == as.character(tangSub[i, 'ewindmonyr']))
  w2 <- max(which(deathyr[idx, ] > 0))
  theta <- svec[w1:w2]
  list(theta = theta, swind = w1, ewind = w2)
}

getSurvvar <- function(theta){
  testVar <- theta * (1 - theta)
  testVar
}

tangSub$sidx <- NA
tangSub$eidx <- NA
tangSub$svals <- NA
tangSub$svar <- NA

for(i in 1:nrow(tangSub)){
  tmp <- getSurv(tangSub$EGNo[i], tangSub)
  
  tangSub$sidx[i]  <- tmp$swind
  tangSub$eidx[i]  <- tmp$ewind
  tangSub$svals[i] <- list(tmp$theta)
  tangSub$svar[i]  <- list(getSurvvar(unlist(tangSub$svals[i])))
}
```

So what does that yield? Four new columns: Two that have the indices that define the start and end of the entanglment/survival window; two that have the monthly survival probability following the end of entanglement, and the variance around that estimate. 

## Reference Animal
Ok, with that built for the entangled animals, we want to sample the reference animals against which we'll compare survival. In practice that means all animals who are:

1. alive for the whole duration of the window we defined for each individual entanglement window _and_ 
2. who are themselves not entangled during that same interval. 

We'll then summarize the mean survival of all those animals for each of the months during the entanglement survival window. Finally to build up the distribution of differences $Z$ we'll sample from two binomials and take the differences. Mathematically, 

\[
Y_1 \sim Bin(\theta_{ent})\\
Y_2 \sim Bin(\theta_{ref})\\
Z = ln\left( \frac{Y_1}{Y_2}\right)

\]

For example, let's say we have a an 8-month entanglement window when the survival probability declines from 1 to 0. During each of these 8 months, we'll calculate the difference in survival between the entangled animal  ($\theta_{ent}$) and the reference class  ($\theta_{ref}$). Each of the entangled animals will have metadata that indicates injury and gender. By building up the distribution of differences we will be able to quantify the impact of entanglement on survival by category, e.g ($Z_{Female, Severe}$). Note that we will only compare females to females, and males to males; that is for an entangled female, the reference class will be comprised solely of females.

The idea is that we want to define our reference class by first figuring out which animals were entangled during the same time frame as our entangled animal. We will exclude this animal as a possible reference. (Note that because each individual's entanglement window is different, the reference class is going to be unique to each animal.) To find the entire entanglement reference window for each animal we start by defining ranges during which the animals were entangled. Also note that we're using a conservative start date for the possible range. This is following discussion in Boston in February 2018 about when the window should start. Here we use the first possible date, as opposed to the windows we agreed upon for the paper.

The logic in the next block is that we define indices for the start and stop of the window. Then we loop over rows, and store the range between those start/stop times as a list column.

```{r}
load("E:/rob/Documents/research/projects/rightWhaleEntanglement/src/data-raw/eg_203_ng_50000_BIG_25000_BIG_25000.rdata")
# Define Ranges of Entanglement for Each Animal
tangleOut$sidx <- match(tangleOut$smonyr, myName)
tangleOut$eidx <- match(tangleOut$ewindmonyr, myName) 
tangleOut$range <- NA
for(i in seq_along(tangleOut$EGNo)){
  tangleOut$range[i] <- list(as.integer(tangleOut[i, 'sidx']):as.integer(tangleOut[i, 'eidx']))
}
```

With those established, then we need to remove any of the reference animals from the candidate list if there is an intersection between the entangled animal and the reference animals. To do this, we have a nested loop that compares each individual event to all possible, and only stores the IDs of the candidate animals that do not intersect in time. The outer loop (i) loops over each of the entangled animals' final entanglement; the inner (j) loop compares the range from the ith animal to all possible reference animals.

```{r}
cand <- vector('list', max(seq_along(tangSub$EGNo)))
possAn <- ID[!(ID %in% unique(tangleAll$EGNo))]
possAnF <- possAn[gender[match(possAn, ID)] == 'F']
possAnM <- possAn[gender[match(possAn, ID)] == 'M']

for(i in seq_along(tangSub$EGNo)) {
  
  # to find range of entangled animal's survival window:
  entRng <- as.integer(tangSub[i, 'sidx']):as.integer(tangSub[i, 'eidx'])   
  candGen <- gender[which(ID == as.integer(tangSub[i, "EGNo"]))]
  candSub <- numeric(0)
  
  # So we can find possible reference animals that are not currently entangled
  for (j in seq_along(tangleOut)) {
    
    refGen <- gender[which(ID == as.integer(tangleOut[j, "EGNo"]))]
    if(candGen != refGen) next() # cuz I only want the same gender
    range1 <- unlist(tangleOut[j, 'range'])
    
    if (!any(range1 %in% entRng)) {
      candSub <- c(candSub, tangleOut$EGNo[j])
    }
    
  }
  
  # So we can find possible reference animals who have never been entangled &
  # alive during the relevant time
  psub <- numeric(0)
  
  # to make the matching smaller in the for loop, i.e. avoid matching 
  # males if we only want females
  if (candGen == 'F') {
    pvec = possAnF 
  } else {
    pvec = possAnM
  }
  
  for (k in seq_along(pvec)) {
    idx <- which(ID == pvec[k])
    prange <- firstSight[idx]:lastSight[idx]
    
    if (any(prange %in% entRng)) {
      psub <- c(psub, pvec[k])
    }
  }
  
  cand[[i]] <- unique(c(candSub, psub))
  
}
```

To recap, each element of the ```cand``` list object is a set of possible candidate reference animals. The animals in each element are of the same gender and satisfy one of two conditions: 

1. they have been entangled, but are not currently entangled (current refers to the reference animal)
2. the have never been entangled, but are alive at the same time as the reference animal

Now we have the data indices we need, and can proceed to building up $Z$,

### Summary of Survival

With that list of possible animals, then we can choose one at random, and assemble its health.

```{r}
cID <- sample(fincand, 1)
cidx <- which(ID == cID)

```


### Distribution of Differences
Once we've sampled from the posterior for each animal, then we have to examine the differences.

```{r}
hdiff <- himpMat - hrefMat
hsurvsum <- rowMeans(hdiff)
hist(hsurvsum, breaks = 30, main = 'Difference Between Impacted and Healthy Animal', xlab = 'Health Units')
```

### Which is the Best Reference Animal
One of the issues the above analysis raises, is how do we know that this is a good animal to compare against? What if we chose a different animal, that for whatever reason led to a skewed result. I'll try to investigate that by comparing the health of this impacted animals against a range of candidates to see what the results look like. Se we can repeat the above calculation, but now do it for all candidate animals, not just this one reference.

```{r}
hdiffList <- vector('list', length(fincand))
ndraw <- 1:1000

for (j in seq_along(fincand)) {
  cID <- fincand[j]
  cidx <- which(ID == cID)

  hmomMean <- healthmean[cidx, startW:endW]
  if(any(is.na(hmomMean))) next
  hmomSD <- healthsd[cidx, startW:endW]
  hrefMat <- matrix(NA, max(ndraw), ncol = length(hmomMean))

  for (i in seq_along(ndraw)){
    hrefMat[i, ] <- rnorm(length(hmomMean), hmomMean, hmomSD)
  }

  hdiffList[[j]] <- data.frame(refAn = cID, meanDiff = rowMeans(himpMat - hrefMat))
}
  
```

We need to create a data frame to make it a bit easier to plot.

```{r}
hdiffList2 = hdiffList[-which(sapply(hdiffList, is.null))]
hdiffdf <- do.call(rbind.data.frame, hdiffList2)
```

With that built up, let's plot it.

```{r}
library(ggplot2)
pall <- ggplot(hdiffdf, aes(meanDiff))+
  geom_density()+
  labs(title = 'All Animals Averaged Together')
pall

p <- ggplot(hdiffdf, aes(meanDiff, group = refAn))+
  geom_density()+
  labs(title = 'All Animals Plotted Separately')
p
```



## Impacts of Entanglement on Survival
Ok, with survival the idea is similar -- we take an impacted animal and look at its survival curve in relationship to a randomly sampled reference individual. There are several different ways to do this. We'll start here by looking at probability of survival for the impacted animal during the entanglement event and compare that to a randomly selected animal. (Here, I'll use a different impacted animal from above because 1014 is an observed dead animal - hence no uncertainty in death.) We then build up the distribution of differences in survival and plot them. Again, as before, the selection of the reference case bears careful consideration. One first set of candidates could be the animals that were never entangled, but there could be year/animal mismatches here once we start sampling more. By this I mean with so few animals that bear no scars, we could end up with year and month combinations where we have an impacted animal, but no reference animal.

Let's look at the posterior, which provides an estimated month the animal died in, and then we can use that to summarize survival.

```{r}
anID <- 1130
idx <- which(ID == anID)
deathyr[idx, 360:375] # this snippet shows the candidate months of death
round(deathyr[idx, 360:375] / ng, 4)
svec <- 1 - cumsum(deathyr[idx, ] / ng) 
svec[1:firstSight[idx]] <- 0
# plot(svec)

test <- round(svec[360:375], 4)
testVar <- test * (1 - test)
plot(test, type = 'l', ylab = 'Survival Probability', xlab = 'Months Following Last Entanglement')
lines(test + testVar, lty = 2)
lines(test - testVar, lty = 2)
```

That represents the survival with uncertainty for one animal between the time of the last entanglement and when survival probability goes to 0. We need to sample from this posterior 1,000 times to build up the distribution of survival probabilities. And then take the difference between that and the survival probabilities of the reference animals. First the entangled whale:

```{r}
probs <- test
survMat <- matrix(NA, nrow = 1000, ncol = length(probs))

for(i in 1:nrow(survMat)) {
  survMat[i, ] <- rbinom(prob = probs, n = length(probs), size = 1)
}

# pvec <- apply(survMat, 2, mean)
```

Next, we find the reference animmals, and as above, build up the survival probabilities. Then we can subtract them to get the distribution of differences. For reference, we'll start with the candidates that we identified above. We need to get the correct date/times selected as well to make sure the comparisons are valid. By this I mean that if our window for the entangled animal is January through July of 2000, then we need to select these times for candidate whales.

```{r candidatePsurv}
canSurv <- matrix(data = NA, nrow = 1000, ncol = fincand)


```

