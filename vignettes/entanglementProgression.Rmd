---
title: "Progression of Entanglement Status"
author: "Rob Schick, PhD"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Progression of Entanglement Status}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
load("../data/tangleOut.rda")
load("E:/rob/Documents/research/projects/rightWhaleEntanglement/src/data/firstSight.rda")
load("E:/rob/Documents/research/projects/rightWhaleEntanglement/src/data/lastSight.rda")
load("E:/rob/Documents/research/projects/rightWhaleEntanglement/src/data/ID.rda")
load("E:/rob/Documents/research/projects/rightWhaleEntanglement/src/data/entvec.rda")
load("E:/rob/Documents/research/projects/rightWhaleEntanglement/src/data/healthmean.rda")
load("E:/rob/Documents/research/projects/rightWhaleEntanglement/src/data/myName.rda")
```

First we're going to loop over animals to assemble an ordinal state vector for each month. The idea here is that the animal starts 'clear' or unentangled. Upon becoming entangled, its status gets updated to the overall entanglement status. The key is that as time progresses, the animal only stays in its worst class, and doesn't recover. We'll have 5 ordinal classes:

* Class 4 - Unentangled
* Class 3 - Minor Entanglement
* Class 2 - Moderate Entanglement
* Class 1 - Severe Entanglement
* Class 0 - Known Dead

To illustrate, let's start with just 50 animals. Each of these animals has experienced more than 1 event (we need that to illustrate progression).

```{r}
sampVal <- 450
canAn <- tangleOut %>% 
  filter(EventNo > 1) %>% 
  select(EGNo) %>% 
  sample_n(sampVal) %>% 
  pull()
canAn <- unique(canAn)
```


We use that vector to pare down the larger data frame:

```{r}
tangled <- tangleOut %>% 
  filter(tangleOut$EGNo %in% canAn) %>% 
  arrange(EGNo)
tangled
```

With the raw data, we can now build up a data structure. I'm going to start with a matrix structure, though maybe I should have this as a list given the different starting and ending dates? TBD. We populate this with 4's under the assumption that all animals start unentangled. We may vary this to NA to deal with the proper alignment to when animals are not yet born

```{r}
dateVec <- seq.Date(as.Date("1970/01/01"), as.Date("2016/12/01"), by = 'month')
fate <- matrix(4, nrow = length(canAn), ncol = length(dateVec))
```

Now let's loop over individuals, and within individuals, entanglement events, to fill in this state matrix.

```{r}
library(lubridate)


for (i in 1:length(unique(tangled$EGNo))){
  eg <- unique(tangled$EGNo)[i]
  dsub <- filter(tangled, EGNo == eg) %>% 
    select(EventNo, Severity, gearInj, StartDateWindow, EndDateWindow)
  
  for(j in 1:nrow(dsub)){
    startPos <- which.min(abs(dateVec - as.Date(dsub$StartDateWindow[j])))
    valStart <- dsub$gearInj[j]
    if(valStart %in% c(6, 4)) val <- 3
    if(valStart %in% c(5, 2)) val <- 2
    if(valStart %in% c(3, 1)) val <- 1
    fate[i, startPos:ncol(fate)] <- val
  }
  
}
```

And then we plot it:

```{r}
library(ggplot2)
plot(dateVec, fate[1, ], type = 'l', ylim = c(0, 4))
for(i in 2:nrow(fate)){
  lines(dateVec, fate[i, ])
}
```

# Pull Out Health
At this point we have approx 50 candidate animals, and we want to plot the health of these groups over time, where groups are defined by the fate value. Probably easiest if I subset the matrix of health values to be the same size as the candidate animals.

```{r}

health <- healthmean[noquote(rownames(healthmean)) %in% canAn, ]
```

My first idea is to loop over columns, and tally the number of animals in each class from fate, and then intersect fate with health to get the summary statistics from each grouping.

```{r}
dfAll <- numeric(0)
for (i in 1:ncol(health)){
  df <- data.frame(id = canAn, health = health[, i], fate = fate[, i])
  dfSummary <- df %>% 
    group_by(fate) %>% 
    summarize(mean = mean(health, na.rm = TRUE), sd = sd(health, na.rm = TRUE)) %>% 
    mutate(time = i)
  dfAll <- rbind(dfAll, dfSummary)
}
```

Ok, with it assembled, let's try and plot it out.

```{r}
library(RColorBrewer)
mypal <- brewer.pal(3, 'Reds')
unentangled <- dfAll %>% filter(fate == 4)
minor <- dfAll %>% filter(fate == 3)
moderate <- dfAll %>% filter(fate == 2)
severe <- dfAll %>% filter(fate == 1)
plot(unentangled$time, unentangled$mean, type = 'l', ylim = c(0, 100))
lines(unentangled$time, unentangled$mean + unentangled$sd, lty = 2)
lines(unentangled$time, unentangled$mean - unentangled$sd, lty = 2)

lines(minor$time, minor$mean, lty = 1, col = mypal[1], lwd = 2)
# lines(minor$time, minor$mean + minor$sd, lty = 2, col = mypal[1])
# lines(minor$time, minor$mean - minor$sd, lty = 2, col = mypal[1])

lines(moderate$time, moderate$mean, lty = 1, col = mypal[2], lwd = 2)
# lines(moderate$time, moderate$mean + moderate$sd, lty = 2, col = mypal[2])
# lines(moderate$time, moderate$mean - moderate$sd, lty = 2, col = mypal[2])

lines(severe$time, severe$mean, lty = 1, col = mypal[3], lwd = 2)
# lines(severe$time, severe$mean + severe$sd, lty = 2, col = mypal[3])
# lines(severe$time, severe$mean - severe$sd, lty = 2, col = mypal[3])
```

